
# [problem](https://leetcode.com/problems/k-inverse-pairs-array/)

这题可以根据 0 ~ n 个数字中有 0 ~ k 个 inverse pair (下称ip) 通过DP求解，难点在于递推式，可以先列个表

| k\n | 1 | 2 | 3 | 4 |
|-----|---|---|---|---|
| 0   | 1 | 1 | 1 | 1 |
| 1   | 0 | 1 | 2 | 3 |
| 2   | 0 | 0 | 2 | 5 |
| 3   | 0 | 0 | 1 | 6 |

可以发现 n = 4 的数据似乎都是左侧和上侧数字的相加，不过也只是猜想，真的要想到还是有点困难的。

这里的核心逻辑是，我们往 n - 1 个数字组成的数组里加上 n 时，可以放置的位置有 n 个，比如放到数组的最后的话就保持当前数组的 k 不变（向 `[2, 1, 3]` 最后插入 4 得到 `[2, 1, 3, 4]`，k是不变的），但如果向前面插入那么 k 就会增加插入位置后的元素个数（[2,1,3] => [2,1,4,3]，k加一）。

所以对于位于 (n, k) 的元素来说，只要向 (n - 1, 0...k) 对应的数组里合理的位置插入当前的n就能得到 n 个数字组成 ip 为 k 的数组，所以 `dp[n][k] = dp[n-1][0] + ... + dp[n-1][k]`。

不过可以发现有些数字明显不符合，是因为 k 实在太大，怎么放到没法得到这样的数组了，比如 `[1, 2]`(k = 0) 里插入 3 怎么都得不到 k 为 3 的结果的，明显能增加的 k 最多为 n - 1，那么可以过滤掉前一列里 k 太小的数据了。

每次都要算k个累计值其实也没必要，因为上一行已经算了前几个的累计了，所以只要将左侧值加上上侧值再减去k太小的 `dp[n-1][k-n]` 即可。